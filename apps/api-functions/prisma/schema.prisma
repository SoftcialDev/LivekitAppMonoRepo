// 1. Datasource & Generator
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // ej. "postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=livekit&sslmode=disable"
}

generator client {
  provider = "prisma-client-js"
}

// 2. Enumerations

/// Distinguishes between super administrators, administrators, and employees.
/// Ahora, suponemos que solo los usuarios con rol Supervisor pueden tener empleados asignados.
enum UserRole {
  Supervisor  // Highest privileges: puede gestionar empleados y otros settings.
  Admin       // Rol intermedio, si aún lo necesitas (puede tener lógica distinta).
  Employee    // Usuario final, asignado a un supervisor.
}

/// A user’s presence status.
enum Status {
  online
  offline
}

// 3. Models

/// Representa un usuario autenticado en Azure AD.
model User {
  /// Primary key: UUID generado por Prisma o en la base.
  /// Puedes usar @default(uuid()) para generar en el cliente, o dbgenerated("gen_random_uuid()") si tienes pgcrypto.
  id              String            @id @default(uuid()) @db.Uuid

  /// Identificador único en Azure AD.
  azureAdObjectId String            @unique

  /// Correo único.
  email           String            @unique

  /// Nombre completo.
  fullName        String

  /// Rol: Supervisor, Admin o Employee.
  role            UserRole

  /// Timestamp cuando cambió el rol.
  roleChangedAt   DateTime?

  /// (Opcional) Referencia al supervisor de este usuario (si es Employee).
  supervisorId    String?           @db.Uuid

  /// Timestamp cuando se asignó a este supervisor.
  assignedAt      DateTime?

  /// Relación: el supervisor (User con rol Supervisor) de este empleado.
  supervisor      User?             @relation("SupervisorToEmployees", fields: [supervisorId], references: [id], onDelete: Cascade)

  /// Relación inversa: lista de empleados asignados a este supervisor.
  employees       User[]            @relation("SupervisorToEmployees")

  /// Relaciones de presencia
  presence        Presence?
  presenceHistory PresenceHistory[]

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  deletedAt       DateTime?

  @@index([supervisorId]) // acelera consultas por supervisorId
}

/// Sigue igual: estado actual online/offline
model Presence {
  userId     String   @id @db.Uuid
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  status     Status
  lastSeenAt DateTime
  updatedAt  DateTime @updatedAt

  @@index([status])
}

/// Historial de conexiones WebSocket
model PresenceHistory {
  id             String   @id @default(uuid()) @db.Uuid
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String   @db.Uuid
  connectedAt    DateTime @default(now())
  disconnectedAt DateTime?
  updatedAt      DateTime @updatedAt

  @@index([userId])
  @@index([connectedAt])
}

/// Comandos pendientes para un empleado. Considera usar una referencia a User en lugar de email si prefieres integridad referencial.
model PendingCommand {
  id            String   @id @default(uuid()) @db.Uuid
  employeeEmail String   // si deseas fuerte integridad, podrías cambiar a employeeId String? y relación a User
  command       String   // "START" | "STOP"
  timestamp     DateTime
  delivered     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}
